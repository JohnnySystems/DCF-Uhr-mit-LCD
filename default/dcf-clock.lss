
dcf-clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ac0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00000ac0  00000b54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000025  00800094  00800094  00000b88  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000b88  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002ef  00000000  00000000  00000bc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b6c  00000000  00000000  00000eb7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000279  00000000  00000000  00001a23  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c52  00000000  00000000  00001c9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000190  00000000  00000000  000028f0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002f7  00000000  00000000  00002a80  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000233  00000000  00000000  00002d77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 66 00 	jmp	0xcc	; 0xcc <__ctors_end>
   4:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
   8:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
   c:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  10:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  14:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  18:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  1c:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  20:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  24:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  28:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  2c:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  30:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  34:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  38:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  3c:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  40:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  44:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  48:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  4c:	0c 94 c4 00 	jmp	0x188	; 0x188 <__vector_19>
  50:	0c 94 83 00 	jmp	0x106	; 0x106 <__bad_interrupt>
  54:	7d 03       	fmul	r23, r21
  56:	82 03       	fmuls	r16, r18
  58:	82 03       	fmuls	r16, r18
  5a:	82 03       	fmuls	r16, r18
  5c:	82 03       	fmuls	r16, r18
  5e:	82 03       	fmuls	r16, r18
  60:	82 03       	fmuls	r16, r18
  62:	82 03       	fmuls	r16, r18
  64:	82 03       	fmuls	r16, r18
  66:	82 03       	fmuls	r16, r18
  68:	82 03       	fmuls	r16, r18
  6a:	82 03       	fmuls	r16, r18
  6c:	82 03       	fmuls	r16, r18
  6e:	82 03       	fmuls	r16, r18
  70:	82 03       	fmuls	r16, r18
  72:	82 03       	fmuls	r16, r18
  74:	82 03       	fmuls	r16, r18
  76:	d0 02       	muls	r29, r16
  78:	82 03       	fmuls	r16, r18
  7a:	82 03       	fmuls	r16, r18
  7c:	82 03       	fmuls	r16, r18
  7e:	d6 02       	muls	r29, r22
  80:	da 02       	muls	r29, r26
  82:	de 02       	muls	r29, r30
  84:	e2 02       	muls	r30, r18
  86:	e6 02       	muls	r30, r22
  88:	ea 02       	muls	r30, r26
  8a:	ee 02       	muls	r30, r30
  8c:	f3 02       	muls	r31, r19
  8e:	f9 02       	muls	r31, r25
  90:	fd 02       	muls	r31, r29
  92:	01 03       	mulsu	r16, r17
  94:	05 03       	mulsu	r16, r21
  96:	09 03       	fmul	r16, r17
  98:	0d 03       	fmul	r16, r21
  9a:	12 03       	mulsu	r17, r18
  9c:	18 03       	fmul	r17, r16
  9e:	1c 03       	fmul	r17, r20
  a0:	20 03       	mulsu	r18, r16
  a2:	24 03       	mulsu	r18, r20
  a4:	28 03       	fmul	r18, r16
  a6:	2c 03       	fmul	r18, r20
  a8:	32 03       	mulsu	r19, r18
  aa:	36 03       	mulsu	r19, r22
  ac:	3a 03       	fmul	r19, r18
  ae:	40 03       	mulsu	r20, r16
  b0:	44 03       	mulsu	r20, r20
  b2:	48 03       	fmul	r20, r16
  b4:	4c 03       	fmul	r20, r20
  b6:	50 03       	mulsu	r21, r16
  b8:	56 03       	mulsu	r21, r22
  ba:	5a 03       	fmul	r21, r18
  bc:	5e 03       	fmul	r21, r22
  be:	62 03       	mulsu	r22, r18
  c0:	66 03       	mulsu	r22, r22
  c2:	6a 03       	fmul	r22, r18
  c4:	6e 03       	fmul	r22, r22
  c6:	72 03       	mulsu	r23, r18
  c8:	77 03       	mulsu	r23, r23
  ca:	7d 03       	fmul	r23, r21

000000cc <__ctors_end>:
  cc:	11 24       	eor	r1, r1
  ce:	1f be       	out	0x3f, r1	; 63
  d0:	cf e5       	ldi	r28, 0x5F	; 95
  d2:	d4 e0       	ldi	r29, 0x04	; 4
  d4:	de bf       	out	0x3e, r29	; 62
  d6:	cd bf       	out	0x3d, r28	; 61

000000d8 <__do_copy_data>:
  d8:	10 e0       	ldi	r17, 0x00	; 0
  da:	a0 e6       	ldi	r26, 0x60	; 96
  dc:	b0 e0       	ldi	r27, 0x00	; 0
  de:	e0 ec       	ldi	r30, 0xC0	; 192
  e0:	fa e0       	ldi	r31, 0x0A	; 10
  e2:	02 c0       	rjmp	.+4      	; 0xe8 <.do_copy_data_start>

000000e4 <.do_copy_data_loop>:
  e4:	05 90       	lpm	r0, Z+
  e6:	0d 92       	st	X+, r0

000000e8 <.do_copy_data_start>:
  e8:	a4 39       	cpi	r26, 0x94	; 148
  ea:	b1 07       	cpc	r27, r17
  ec:	d9 f7       	brne	.-10     	; 0xe4 <.do_copy_data_loop>

000000ee <__do_clear_bss>:
  ee:	10 e0       	ldi	r17, 0x00	; 0
  f0:	a4 e9       	ldi	r26, 0x94	; 148
  f2:	b0 e0       	ldi	r27, 0x00	; 0
  f4:	01 c0       	rjmp	.+2      	; 0xf8 <.do_clear_bss_start>

000000f6 <.do_clear_bss_loop>:
  f6:	1d 92       	st	X+, r1

000000f8 <.do_clear_bss_start>:
  f8:	a9 3b       	cpi	r26, 0xB9	; 185
  fa:	b1 07       	cpc	r27, r17
  fc:	e1 f7       	brne	.-8      	; 0xf6 <.do_clear_bss_loop>
  fe:	0e 94 46 04 	call	0x88c	; 0x88c <main>
 102:	0c 94 5e 05 	jmp	0xabc	; 0xabc <_exit>

00000106 <__bad_interrupt>:
 106:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010a <counter_reset>:
////////////////////
//Reset-Funktionen//
////////////////////
void counter_reset(void)
{
	counter_high=0;
 10a:	10 92 b7 00 	sts	0x00B7, r1
 10e:	10 92 b6 00 	sts	0x00B6, r1
	counter_low=0;
 112:	10 92 b5 00 	sts	0x00B5, r1
 116:	10 92 b4 00 	sts	0x00B4, r1
	bit_number=0;
 11a:	10 92 b8 00 	sts	0x00B8, r1
}
 11e:	08 95       	ret

00000120 <dcf_date_reset>:

void dcf_date_reset(void)
{
	dcf_week_day=0;
 120:	10 92 98 00 	sts	0x0098, r1
	dcf_day=0;
 124:	10 92 9e 00 	sts	0x009E, r1
	dcf_month=0;
 128:	10 92 ab 00 	sts	0x00AB, r1
	dcf_year=0;
 12c:	10 92 9a 00 	sts	0x009A, r1
	dcf_date_parity=0;
 130:	10 92 a9 00 	sts	0x00A9, r1
}
 134:	08 95       	ret

00000136 <dcf_time_reset>:

void dcf_time_reset(void)
{
	dcf_minute=0;
 136:	10 92 a8 00 	sts	0x00A8, r1
	dcf_minute_parity=0;
 13a:	10 92 a4 00 	sts	0x00A4, r1
	dcf_hour=0;
 13e:	10 92 96 00 	sts	0x0096, r1
	dcf_hour_parity=0;
 142:	10 92 99 00 	sts	0x0099, r1
	dcf_timezone=0;
 146:	10 92 97 00 	sts	0x0097, r1
}
 14a:	08 95       	ret

0000014c <leap_year>:
/////////////////////////
//Berechnung Schaltjahr//
/////////////////////////
void leap_year(void)
{
	if(year%4==0 && year%100!=0)
 14c:	20 91 a5 00 	lds	r18, 0x00A5
 150:	30 91 a6 00 	lds	r19, 0x00A6
 154:	c9 01       	movw	r24, r18
 156:	83 70       	andi	r24, 0x03	; 3
 158:	90 70       	andi	r25, 0x00	; 0
 15a:	89 2b       	or	r24, r25
 15c:	91 f4       	brne	.+36     	; 0x182 <leap_year+0x36>
 15e:	c9 01       	movw	r24, r18
 160:	64 e6       	ldi	r22, 0x64	; 100
 162:	70 e0       	ldi	r23, 0x00	; 0
 164:	0e 94 19 05 	call	0xa32	; 0xa32 <__udivmodhi4>
 168:	89 2b       	or	r24, r25
 16a:	39 f4       	brne	.+14     	; 0x17a <leap_year+0x2e>
		{
			leapyear=0;//Kein Schaltjahr, da nicht durch 4 teilbar
		}
		else
		{
			if(year%400==0)
 16c:	c9 01       	movw	r24, r18
 16e:	60 e9       	ldi	r22, 0x90	; 144
 170:	71 e0       	ldi	r23, 0x01	; 1
 172:	0e 94 19 05 	call	0xa32	; 0xa32 <__udivmodhi4>
 176:	89 2b       	or	r24, r25
 178:	21 f4       	brne	.+8      	; 0x182 <leap_year+0x36>
			{
				leapyear=1;//Schaltjahre, da durch 400 teilbar
 17a:	81 e0       	ldi	r24, 0x01	; 1
 17c:	80 93 9b 00 	sts	0x009B, r24
 180:	08 95       	ret
			}
			else
			{
				leapyear=0;//Kein Schaltjahr, da durch 100 teilbar aber nicht durch 400
 182:	10 92 9b 00 	sts	0x009B, r1
 186:	08 95       	ret

00000188 <__vector_19>:
/////////////////////////////
//Interrupt Service Routine//
/////////////////////////////
//Der Compare Interrupt Handler wird aufgerufen, wenn TCNT0 = OCR0 = 250-1 ist (250 Schritte), d.h. genau alle 1 ms
ISR (TIMER0_COMP_vect)
{
 188:	1f 92       	push	r1
 18a:	0f 92       	push	r0
 18c:	0f b6       	in	r0, 0x3f	; 63
 18e:	0f 92       	push	r0
 190:	11 24       	eor	r1, r1
 192:	2f 93       	push	r18
 194:	3f 93       	push	r19
 196:	4f 93       	push	r20
 198:	5f 93       	push	r21
 19a:	6f 93       	push	r22
 19c:	7f 93       	push	r23
 19e:	8f 93       	push	r24
 1a0:	9f 93       	push	r25
 1a2:	af 93       	push	r26
 1a4:	bf 93       	push	r27
 1a6:	ef 93       	push	r30
 1a8:	ff 93       	push	r31
	millisecond++;	//Counter für die Millisekunden
 1aa:	20 91 94 00 	lds	r18, 0x0094
 1ae:	30 91 95 00 	lds	r19, 0x0095
 1b2:	2f 5f       	subi	r18, 0xFF	; 255
 1b4:	3f 4f       	sbci	r19, 0xFF	; 255
 1b6:	30 93 95 00 	sts	0x0095, r19
 1ba:	20 93 94 00 	sts	0x0094, r18
	dataPC = PINC;	//Der aktuelle Pegel vom DCF-Modul wird eingelesen und in dataPC den anderen Funktionen zur Verfügung gestellt
 1be:	83 b3       	in	r24, 0x13	; 19
 1c0:	80 93 a3 00 	sts	0x00A3, r24
	counter_high++;	//Counter für die Bit-Auswertung (Dauer des High-Pegels), Rücksetzen muß in den Funktionen geschehen
 1c4:	80 91 b6 00 	lds	r24, 0x00B6
 1c8:	90 91 b7 00 	lds	r25, 0x00B7
 1cc:	01 96       	adiw	r24, 0x01	; 1
 1ce:	90 93 b7 00 	sts	0x00B7, r25
 1d2:	80 93 b6 00 	sts	0x00B6, r24
	counter_low++;	//Counter für die Bit-Auswertung (Dauer des Low-Pegels), Rücksetzen muß in den Funktionen geschehen
 1d6:	80 91 b4 00 	lds	r24, 0x00B4
 1da:	90 91 b5 00 	lds	r25, 0x00B5
 1de:	01 96       	adiw	r24, 0x01	; 1
 1e0:	90 93 b5 00 	sts	0x00B5, r25
 1e4:	80 93 b4 00 	sts	0x00B4, r24
	if(millisecond==1000)	//"selbstlaufende" Uhr
 1e8:	28 5e       	subi	r18, 0xE8	; 232
 1ea:	33 40       	sbci	r19, 0x03	; 3
 1ec:	09 f0       	breq	.+2      	; 0x1f0 <__vector_19+0x68>
 1ee:	86 c0       	rjmp	.+268    	; 0x2fc <__vector_19+0x174>
	{
		second++;
 1f0:	80 91 9d 00 	lds	r24, 0x009D
 1f4:	8f 5f       	subi	r24, 0xFF	; 255
 1f6:	80 93 9d 00 	sts	0x009D, r24
		millisecond=0;
 1fa:	10 92 95 00 	sts	0x0095, r1
 1fe:	10 92 94 00 	sts	0x0094, r1
		if(second==60)
 202:	8c 33       	cpi	r24, 0x3C	; 60
 204:	39 f4       	brne	.+14     	; 0x214 <__vector_19+0x8c>
		{
			minute++;
 206:	80 91 9f 00 	lds	r24, 0x009F
 20a:	8f 5f       	subi	r24, 0xFF	; 255
 20c:	80 93 9f 00 	sts	0x009F, r24
			second=0;
 210:	10 92 9d 00 	sts	0x009D, r1
		}
		if(minute==60)
 214:	80 91 9f 00 	lds	r24, 0x009F
 218:	8c 33       	cpi	r24, 0x3C	; 60
 21a:	39 f4       	brne	.+14     	; 0x22a <__vector_19+0xa2>
		{
			hour++;
 21c:	80 91 a1 00 	lds	r24, 0x00A1
 220:	8f 5f       	subi	r24, 0xFF	; 255
 222:	80 93 a1 00 	sts	0x00A1, r24
			minute=0;
 226:	10 92 9f 00 	sts	0x009F, r1
		}
		if(hour==24)
 22a:	80 91 a1 00 	lds	r24, 0x00A1
 22e:	88 31       	cpi	r24, 0x18	; 24
 230:	61 f4       	brne	.+24     	; 0x24a <__vector_19+0xc2>
		{
			day++;
 232:	80 91 a7 00 	lds	r24, 0x00A7
 236:	8f 5f       	subi	r24, 0xFF	; 255
 238:	80 93 a7 00 	sts	0x00A7, r24
			week_day++;
 23c:	80 91 a2 00 	lds	r24, 0x00A2
 240:	8f 5f       	subi	r24, 0xFF	; 255
 242:	80 93 a2 00 	sts	0x00A2, r24
			hour=0;
 246:	10 92 a1 00 	sts	0x00A1, r1
		}
		if(week_day==8)
 24a:	80 91 a2 00 	lds	r24, 0x00A2
 24e:	88 30       	cpi	r24, 0x08	; 8
 250:	19 f4       	brne	.+6      	; 0x258 <__vector_19+0xd0>
		{
			week_day=1;
 252:	81 e0       	ldi	r24, 0x01	; 1
 254:	80 93 a2 00 	sts	0x00A2, r24
		}
		switch(day)
 258:	80 91 a7 00 	lds	r24, 0x00A7
 25c:	8d 31       	cpi	r24, 0x1D	; 29
 25e:	a9 f0       	breq	.+42     	; 0x28a <__vector_19+0x102>
 260:	8e 31       	cpi	r24, 0x1E	; 30
 262:	18 f4       	brcc	.+6      	; 0x26a <__vector_19+0xe2>
 264:	8c 31       	cpi	r24, 0x1C	; 28
 266:	e9 f5       	brne	.+122    	; 0x2e2 <__vector_19+0x15a>
 268:	05 c0       	rjmp	.+10     	; 0x274 <__vector_19+0xec>
 26a:	8e 31       	cpi	r24, 0x1E	; 30
 26c:	d1 f0       	breq	.+52     	; 0x2a2 <__vector_19+0x11a>
 26e:	8f 31       	cpi	r24, 0x1F	; 31
 270:	c1 f5       	brne	.+112    	; 0x2e2 <__vector_19+0x15a>
 272:	22 c0       	rjmp	.+68     	; 0x2b8 <__vector_19+0x130>
		{
			case 28:
			{
				leap_year();
 274:	0e 94 a6 00 	call	0x14c	; 0x14c <leap_year>
				if(month==2 && leapyear==0)
 278:	80 91 9c 00 	lds	r24, 0x009C
 27c:	82 30       	cpi	r24, 0x02	; 2
 27e:	89 f5       	brne	.+98     	; 0x2e2 <__vector_19+0x15a>
 280:	80 91 9b 00 	lds	r24, 0x009B
 284:	88 23       	and	r24, r24
 286:	69 f5       	brne	.+90     	; 0x2e2 <__vector_19+0x15a>
 288:	0a c0       	rjmp	.+20     	; 0x29e <__vector_19+0x116>
			}
			break;

			case 29:
			{
				leap_year();
 28a:	0e 94 a6 00 	call	0x14c	; 0x14c <leap_year>
				if(month==2 && leapyear==1)
 28e:	80 91 9c 00 	lds	r24, 0x009C
 292:	82 30       	cpi	r24, 0x02	; 2
 294:	31 f5       	brne	.+76     	; 0x2e2 <__vector_19+0x15a>
 296:	80 91 9b 00 	lds	r24, 0x009B
 29a:	81 30       	cpi	r24, 0x01	; 1
 29c:	11 f5       	brne	.+68     	; 0x2e2 <__vector_19+0x15a>
				{
					month++;
 29e:	83 e0       	ldi	r24, 0x03	; 3
 2a0:	1c c0       	rjmp	.+56     	; 0x2da <__vector_19+0x152>
			}
			break;

			case 30:
			{
				if(month==4 || month==6 || month==9 || month==11)
 2a2:	80 91 9c 00 	lds	r24, 0x009C
 2a6:	84 30       	cpi	r24, 0x04	; 4
 2a8:	b9 f0       	breq	.+46     	; 0x2d8 <__vector_19+0x150>
 2aa:	86 30       	cpi	r24, 0x06	; 6
 2ac:	a9 f0       	breq	.+42     	; 0x2d8 <__vector_19+0x150>
 2ae:	89 30       	cpi	r24, 0x09	; 9
 2b0:	99 f0       	breq	.+38     	; 0x2d8 <__vector_19+0x150>
 2b2:	8b 30       	cpi	r24, 0x0B	; 11
 2b4:	b1 f4       	brne	.+44     	; 0x2e2 <__vector_19+0x15a>
 2b6:	10 c0       	rjmp	.+32     	; 0x2d8 <__vector_19+0x150>
			}
			break;

			case 31:
			{
				if(month==1 || month==3 || month==5 || month==7|| month==8 || month==10 || month==12)
 2b8:	80 91 9c 00 	lds	r24, 0x009C
 2bc:	81 30       	cpi	r24, 0x01	; 1
 2be:	61 f0       	breq	.+24     	; 0x2d8 <__vector_19+0x150>
 2c0:	83 30       	cpi	r24, 0x03	; 3
 2c2:	51 f0       	breq	.+20     	; 0x2d8 <__vector_19+0x150>
 2c4:	85 30       	cpi	r24, 0x05	; 5
 2c6:	41 f0       	breq	.+16     	; 0x2d8 <__vector_19+0x150>
 2c8:	87 30       	cpi	r24, 0x07	; 7
 2ca:	31 f0       	breq	.+12     	; 0x2d8 <__vector_19+0x150>
 2cc:	88 30       	cpi	r24, 0x08	; 8
 2ce:	21 f0       	breq	.+8      	; 0x2d8 <__vector_19+0x150>
 2d0:	8a 30       	cpi	r24, 0x0A	; 10
 2d2:	11 f0       	breq	.+4      	; 0x2d8 <__vector_19+0x150>
 2d4:	8c 30       	cpi	r24, 0x0C	; 12
 2d6:	29 f4       	brne	.+10     	; 0x2e2 <__vector_19+0x15a>
				{
					month++;
 2d8:	8f 5f       	subi	r24, 0xFF	; 255
 2da:	80 93 9c 00 	sts	0x009C, r24
					day=0;
 2de:	10 92 a7 00 	sts	0x00A7, r1
			}
			break;

			default: ;break;
		}
		if(month==12)
 2e2:	80 91 9c 00 	lds	r24, 0x009C
 2e6:	8c 30       	cpi	r24, 0x0C	; 12
 2e8:	49 f4       	brne	.+18     	; 0x2fc <__vector_19+0x174>
		{
			year++;
 2ea:	80 91 a5 00 	lds	r24, 0x00A5
 2ee:	90 91 a6 00 	lds	r25, 0x00A6
 2f2:	01 96       	adiw	r24, 0x01	; 1
 2f4:	90 93 a6 00 	sts	0x00A6, r25
 2f8:	80 93 a5 00 	sts	0x00A5, r24
		}
	}
}
 2fc:	ff 91       	pop	r31
 2fe:	ef 91       	pop	r30
 300:	bf 91       	pop	r27
 302:	af 91       	pop	r26
 304:	9f 91       	pop	r25
 306:	8f 91       	pop	r24
 308:	7f 91       	pop	r23
 30a:	6f 91       	pop	r22
 30c:	5f 91       	pop	r21
 30e:	4f 91       	pop	r20
 310:	3f 91       	pop	r19
 312:	2f 91       	pop	r18
 314:	0f 90       	pop	r0
 316:	0f be       	out	0x3f, r0	; 63
 318:	0f 90       	pop	r0
 31a:	1f 90       	pop	r1
 31c:	18 95       	reti

0000031e <match_date>:
////////////////////////////////////////////////////////
//Zusammenführung der internen Daten und der DCF-Daten//
////////////////////////////////////////////////////////
void match_date(void)
{
	week_day=dcf_week_day;
 31e:	80 91 98 00 	lds	r24, 0x0098
 322:	80 93 a2 00 	sts	0x00A2, r24
	day=dcf_day;
 326:	80 91 9e 00 	lds	r24, 0x009E
 32a:	80 93 a7 00 	sts	0x00A7, r24
	month=dcf_month;
 32e:	80 91 ab 00 	lds	r24, 0x00AB
 332:	80 93 9c 00 	sts	0x009C, r24
	year=2000+dcf_year;
 336:	80 91 9a 00 	lds	r24, 0x009A
 33a:	90 e0       	ldi	r25, 0x00	; 0
 33c:	80 53       	subi	r24, 0x30	; 48
 33e:	98 4f       	sbci	r25, 0xF8	; 248
 340:	90 93 a6 00 	sts	0x00A6, r25
 344:	80 93 a5 00 	sts	0x00A5, r24
}
 348:	08 95       	ret

0000034a <match_time>:

void match_time(void)
{
	millisecond=0;
 34a:	10 92 95 00 	sts	0x0095, r1
 34e:	10 92 94 00 	sts	0x0094, r1
	second=0;
 352:	10 92 9d 00 	sts	0x009D, r1
	minute=dcf_minute;
 356:	80 91 a8 00 	lds	r24, 0x00A8
 35a:	80 93 9f 00 	sts	0x009F, r24
	hour=dcf_hour;
 35e:	80 91 96 00 	lds	r24, 0x0096
 362:	80 93 a1 00 	sts	0x00A1, r24
	timezone=dcf_timezone;
 366:	80 91 97 00 	lds	r24, 0x0097
 36a:	80 93 a0 00 	sts	0x00A0, r24
}
 36e:	08 95       	ret

00000370 <leading_0>:
//Sonstiges//
/////////////
//Eine führende 0 ergänzen bei Zahlen kleiner/gleich 9
void leading_0(uint8_t digit)
{
	if(digit<=9)
 370:	8a 30       	cpi	r24, 0x0A	; 10
 372:	18 f4       	brcc	.+6      	; 0x37a <leading_0+0xa>
	{
		lcd_data('0');
 374:	80 e3       	ldi	r24, 0x30	; 48
 376:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>
 37a:	08 95       	ret

0000037c <show_matched_time>:
}

//Zusammengeführte Zeit
void show_matched_time(uint8_t column,uint8_t row)	//Übergabe der Cursorposition (Spalte,Zeile)
{
	set_cursor(column,row);
 37c:	0e 94 d7 04 	call	0x9ae	; 0x9ae <set_cursor>

	//LCD-Ausgabe: Stunde
	leading_0(hour);
 380:	80 91 a1 00 	lds	r24, 0x00A1
 384:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
	itoa(hour,itoa_buffer,10);
 388:	80 91 a1 00 	lds	r24, 0x00A1
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	6c ea       	ldi	r22, 0xAC	; 172
 390:	70 e0       	ldi	r23, 0x00	; 0
 392:	4a e0       	ldi	r20, 0x0A	; 10
 394:	50 e0       	ldi	r21, 0x00	; 0
 396:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 39a:	8c ea       	ldi	r24, 0xAC	; 172
 39c:	90 e0       	ldi	r25, 0x00	; 0
 39e:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	lcd_data(':');
 3a2:	8a e3       	ldi	r24, 0x3A	; 58
 3a4:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>

	//LCD-Ausgabe: Minute
	leading_0(minute);
 3a8:	80 91 9f 00 	lds	r24, 0x009F
 3ac:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
 	itoa(minute,itoa_buffer,10);
 3b0:	80 91 9f 00 	lds	r24, 0x009F
 3b4:	90 e0       	ldi	r25, 0x00	; 0
 3b6:	6c ea       	ldi	r22, 0xAC	; 172
 3b8:	70 e0       	ldi	r23, 0x00	; 0
 3ba:	4a e0       	ldi	r20, 0x0A	; 10
 3bc:	50 e0       	ldi	r21, 0x00	; 0
 3be:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 3c2:	8c ea       	ldi	r24, 0xAC	; 172
 3c4:	90 e0       	ldi	r25, 0x00	; 0
 3c6:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	lcd_data(':');
 3ca:	8a e3       	ldi	r24, 0x3A	; 58
 3cc:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>

	//LCD-Ausgabe: Sekunde
	leading_0(second);
 3d0:	80 91 9d 00 	lds	r24, 0x009D
 3d4:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
 	itoa(second,itoa_buffer,10);
 3d8:	80 91 9d 00 	lds	r24, 0x009D
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	6c ea       	ldi	r22, 0xAC	; 172
 3e0:	70 e0       	ldi	r23, 0x00	; 0
 3e2:	4a e0       	ldi	r20, 0x0A	; 10
 3e4:	50 e0       	ldi	r21, 0x00	; 0
 3e6:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 3ea:	8c ea       	ldi	r24, 0xAC	; 172
 3ec:	90 e0       	ldi	r25, 0x00	; 0
 3ee:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	lcd_data(' ');
 3f2:	80 e2       	ldi	r24, 0x20	; 32
 3f4:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>

	//LCD-Ausgabe: Zeitzone
	switch(timezone)
 3f8:	80 91 a0 00 	lds	r24, 0x00A0
 3fc:	88 23       	and	r24, r24
 3fe:	19 f0       	breq	.+6      	; 0x406 <show_matched_time+0x8a>
 400:	82 30       	cpi	r24, 0x02	; 2
 402:	39 f4       	brne	.+14     	; 0x412 <show_matched_time+0x96>
 404:	03 c0       	rjmp	.+6      	; 0x40c <show_matched_time+0x90>
	{
		case 0: lcd_string(" MEZ ");break;	//Ausgabe: Mitteleuropäische Zeit
 406:	80 e6       	ldi	r24, 0x60	; 96
 408:	90 e0       	ldi	r25, 0x00	; 0
 40a:	05 c0       	rjmp	.+10     	; 0x416 <show_matched_time+0x9a>
		case 2: lcd_string(" MESZ");break;	//Ausgabe: Mitteleuropäische Sommerzeit
 40c:	86 e6       	ldi	r24, 0x66	; 102
 40e:	90 e0       	ldi	r25, 0x00	; 0
 410:	02 c0       	rjmp	.+4      	; 0x416 <show_matched_time+0x9a>
		default: lcd_string(" NOTZ");break;	//"No timezone"(NOTZ): Bitfehler bei der Auswertung der Zeitzone
 412:	8c e6       	ldi	r24, 0x6C	; 108
 414:	90 e0       	ldi	r25, 0x00	; 0
 416:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
 41a:	08 95       	ret

0000041c <show_matched_date>:
//LCD-Ausgaben//
////////////////
//Zusammengeführtes Datum
void show_matched_date(uint8_t column,uint8_t row)	//Übergabe der Cursorposition (Spalte,Zeile)
{
	set_cursor(column,row);
 41c:	0e 94 d7 04 	call	0x9ae	; 0x9ae <set_cursor>

	//LCD-Ausgabe: Wochentag
	switch(week_day)
 420:	80 91 a2 00 	lds	r24, 0x00A2
 424:	84 30       	cpi	r24, 0x04	; 4
 426:	c9 f0       	breq	.+50     	; 0x45a <show_matched_date+0x3e>
 428:	85 30       	cpi	r24, 0x05	; 5
 42a:	38 f4       	brcc	.+14     	; 0x43a <show_matched_date+0x1e>
 42c:	82 30       	cpi	r24, 0x02	; 2
 42e:	79 f0       	breq	.+30     	; 0x44e <show_matched_date+0x32>
 430:	83 30       	cpi	r24, 0x03	; 3
 432:	80 f4       	brcc	.+32     	; 0x454 <show_matched_date+0x38>
 434:	81 30       	cpi	r24, 0x01	; 1
 436:	e9 f4       	brne	.+58     	; 0x472 <__stack+0x13>
 438:	07 c0       	rjmp	.+14     	; 0x448 <show_matched_date+0x2c>
 43a:	86 30       	cpi	r24, 0x06	; 6
 43c:	a1 f0       	breq	.+40     	; 0x466 <__stack+0x7>
 43e:	86 30       	cpi	r24, 0x06	; 6
 440:	78 f0       	brcs	.+30     	; 0x460 <__stack+0x1>
 442:	87 30       	cpi	r24, 0x07	; 7
 444:	b1 f4       	brne	.+44     	; 0x472 <__stack+0x13>
 446:	12 c0       	rjmp	.+36     	; 0x46c <__stack+0xd>
	{
		case 1: lcd_string("Mo ");break;	//LCD-Ausgabe: Montag
 448:	82 e7       	ldi	r24, 0x72	; 114
 44a:	90 e0       	ldi	r25, 0x00	; 0
 44c:	14 c0       	rjmp	.+40     	; 0x476 <__stack+0x17>
		case 2: lcd_string("Di ");break;	//LCD-Ausgabe: Dienstag
 44e:	86 e7       	ldi	r24, 0x76	; 118
 450:	90 e0       	ldi	r25, 0x00	; 0
 452:	11 c0       	rjmp	.+34     	; 0x476 <__stack+0x17>
		case 3: lcd_string("Mi ");break;	//LCD-Ausgabe: Mittwoch
 454:	8a e7       	ldi	r24, 0x7A	; 122
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	0e c0       	rjmp	.+28     	; 0x476 <__stack+0x17>
		case 4: lcd_string("Do ");break;	//LCD-Ausgabe: Donnerstag
 45a:	8e e7       	ldi	r24, 0x7E	; 126
 45c:	90 e0       	ldi	r25, 0x00	; 0
 45e:	0b c0       	rjmp	.+22     	; 0x476 <__stack+0x17>
		case 5: lcd_string("Fr ");break;	//LCD-Ausgabe: Freitag
 460:	82 e8       	ldi	r24, 0x82	; 130
 462:	90 e0       	ldi	r25, 0x00	; 0
 464:	08 c0       	rjmp	.+16     	; 0x476 <__stack+0x17>
		case 6: lcd_string("Sa ");break;	//LCD-Ausgabe: Samstag
 466:	86 e8       	ldi	r24, 0x86	; 134
 468:	90 e0       	ldi	r25, 0x00	; 0
 46a:	05 c0       	rjmp	.+10     	; 0x476 <__stack+0x17>
		case 7: lcd_string("So ");break;	//LCD-Ausgabe: Sonntag
 46c:	8a e8       	ldi	r24, 0x8A	; 138
 46e:	90 e0       	ldi	r25, 0x00	; 0
 470:	02 c0       	rjmp	.+4      	; 0x476 <__stack+0x17>
		default: lcd_string("   ");break;
 472:	8e e8       	ldi	r24, 0x8E	; 142
 474:	90 e0       	ldi	r25, 0x00	; 0
 476:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	}

	//LCD-Ausgabe: Tag
	leading_0(day);
 47a:	80 91 a7 00 	lds	r24, 0x00A7
 47e:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
	itoa(day,itoa_buffer,10);
 482:	80 91 a7 00 	lds	r24, 0x00A7
 486:	90 e0       	ldi	r25, 0x00	; 0
 488:	6c ea       	ldi	r22, 0xAC	; 172
 48a:	70 e0       	ldi	r23, 0x00	; 0
 48c:	4a e0       	ldi	r20, 0x0A	; 10
 48e:	50 e0       	ldi	r21, 0x00	; 0
 490:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 494:	8c ea       	ldi	r24, 0xAC	; 172
 496:	90 e0       	ldi	r25, 0x00	; 0
 498:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	lcd_data('.');
 49c:	8e e2       	ldi	r24, 0x2E	; 46
 49e:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>

	//LCD-Ausgabe: Monat
	leading_0(month);
 4a2:	80 91 9c 00 	lds	r24, 0x009C
 4a6:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
 	itoa(month,itoa_buffer,10);
 4aa:	80 91 9c 00 	lds	r24, 0x009C
 4ae:	90 e0       	ldi	r25, 0x00	; 0
 4b0:	6c ea       	ldi	r22, 0xAC	; 172
 4b2:	70 e0       	ldi	r23, 0x00	; 0
 4b4:	4a e0       	ldi	r20, 0x0A	; 10
 4b6:	50 e0       	ldi	r21, 0x00	; 0
 4b8:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 4bc:	8c ea       	ldi	r24, 0xAC	; 172
 4be:	90 e0       	ldi	r25, 0x00	; 0
 4c0:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
	lcd_string(".");
 4c4:	82 e9       	ldi	r24, 0x92	; 146
 4c6:	90 e0       	ldi	r25, 0x00	; 0
 4c8:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>

	//LCD-Ausgabe: Jahreszahl
	leading_0(year);
 4cc:	80 91 a5 00 	lds	r24, 0x00A5
 4d0:	0e 94 b8 01 	call	0x370	; 0x370 <leading_0>
 	itoa(year,itoa_buffer,10);
 4d4:	80 91 a5 00 	lds	r24, 0x00A5
 4d8:	90 91 a6 00 	lds	r25, 0x00A6
 4dc:	6c ea       	ldi	r22, 0xAC	; 172
 4de:	70 e0       	ldi	r23, 0x00	; 0
 4e0:	4a e0       	ldi	r20, 0x0A	; 10
 4e2:	50 e0       	ldi	r21, 0x00	; 0
 4e4:	0e 94 2d 05 	call	0xa5a	; 0xa5a <itoa>
	lcd_string(itoa_buffer);
 4e8:	8c ea       	ldi	r24, 0xAC	; 172
 4ea:	90 e0       	ldi	r25, 0x00	; 0
 4ec:	0e 94 0c 05 	call	0xa18	; 0xa18 <lcd_string>
}
 4f0:	08 95       	ret

000004f2 <dcf_sync>:
//High-Pegel muß für 1700-1900ms anliegen
//Danach muß ein Low-Pegel folgen
void dcf_sync(void)
{
//	show_time(0,2);
	show_matched_date(0,1);
 4f2:	80 e0       	ldi	r24, 0x00	; 0
 4f4:	61 e0       	ldi	r22, 0x01	; 1
 4f6:	0e 94 0e 02 	call	0x41c	; 0x41c <show_matched_date>
	show_matched_time(0,2);
 4fa:	80 e0       	ldi	r24, 0x00	; 0
 4fc:	62 e0       	ldi	r22, 0x02	; 2
 4fe:	0e 94 be 01 	call	0x37c	; 0x37c <show_matched_time>

	//LCD-Ausgabe: Synchronisation läuft gerade
	set_cursor(19,1);
 502:	83 e1       	ldi	r24, 0x13	; 19
 504:	61 e0       	ldi	r22, 0x01	; 1
 506:	0e 94 d7 04 	call	0x9ae	; 0x9ae <set_cursor>
	lcd_data('?');
 50a:	8f e3       	ldi	r24, 0x3F	; 63
 50c:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>

	if(!(dataPC & (1<<PINC1)))
 510:	80 91 a3 00 	lds	r24, 0x00A3
 514:	81 fd       	sbrc	r24, 1
 516:	ed cf       	rjmp	.-38     	; 0x4f2 <dcf_sync>
	{
		if(counter_high>=1750 && counter_high<=1950)
 518:	80 91 b6 00 	lds	r24, 0x00B6
 51c:	90 91 b7 00 	lds	r25, 0x00B7
 520:	86 5d       	subi	r24, 0xD6	; 214
 522:	96 40       	sbci	r25, 0x06	; 6
 524:	89 3c       	cpi	r24, 0xC9	; 201
 526:	91 05       	cpc	r25, r1
 528:	30 f5       	brcc	.+76     	; 0x576 <dcf_sync+0x84>
		{
			//LCD-Ausgabe: Synchronisation erfolgreich
			set_cursor(19,1);
 52a:	83 e1       	ldi	r24, 0x13	; 19
 52c:	61 e0       	ldi	r22, 0x01	; 1
 52e:	0e 94 d7 04 	call	0x9ae	; 0x9ae <set_cursor>
			lcd_data('!');
 532:	81 e2       	ldi	r24, 0x21	; 33
 534:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>
////////////////////
//Reset-Funktionen//
////////////////////
void counter_reset(void)
{
	counter_high=0;
 538:	10 92 b7 00 	sts	0x00B7, r1
 53c:	10 92 b6 00 	sts	0x00B6, r1
	counter_low=0;
 540:	10 92 b5 00 	sts	0x00B5, r1
 544:	10 92 b4 00 	sts	0x00B4, r1
	bit_number=0;
 548:	10 92 b8 00 	sts	0x00B8, r1
}

void dcf_date_reset(void)
{
	dcf_week_day=0;
 54c:	10 92 98 00 	sts	0x0098, r1
	dcf_day=0;
 550:	10 92 9e 00 	sts	0x009E, r1
	dcf_month=0;
 554:	10 92 ab 00 	sts	0x00AB, r1
	dcf_year=0;
 558:	10 92 9a 00 	sts	0x009A, r1
	dcf_date_parity=0;
 55c:	10 92 a9 00 	sts	0x00A9, r1
}

void dcf_time_reset(void)
{
	dcf_minute=0;
 560:	10 92 a8 00 	sts	0x00A8, r1
	dcf_minute_parity=0;
 564:	10 92 a4 00 	sts	0x00A4, r1
	dcf_hour=0;
 568:	10 92 96 00 	sts	0x0096, r1
	dcf_hour_parity=0;
 56c:	10 92 99 00 	sts	0x0099, r1
	dcf_timezone=0;
 570:	10 92 97 00 	sts	0x0097, r1
	}
	else
	{
		dcf_sync();
	}
}
 574:	08 95       	ret
			dcf_date_reset();
			dcf_time_reset();
		}
		else
		{
			counter_high=0;
 576:	10 92 b7 00 	sts	0x00B7, r1
 57a:	10 92 b6 00 	sts	0x00B6, r1
 57e:	b9 cf       	rjmp	.-142    	; 0x4f2 <dcf_sync>

00000580 <dcf_1>:
	}
}

void dcf_1(void)
{
	switch(bit_number)
 580:	80 91 b8 00 	lds	r24, 0x00B8
 584:	e8 2f       	mov	r30, r24
 586:	f0 e0       	ldi	r31, 0x00	; 0
 588:	ec 33       	cpi	r30, 0x3C	; 60
 58a:	f1 05       	cpc	r31, r1
 58c:	08 f0       	brcs	.+2      	; 0x590 <dcf_1+0x10>
 58e:	b8 c0       	rjmp	.+368    	; 0x700 <dcf_1+0x180>
 590:	e6 5d       	subi	r30, 0xD6	; 214
 592:	ff 4f       	sbci	r31, 0xFF	; 255
 594:	ee 0f       	add	r30, r30
 596:	ff 1f       	adc	r31, r31
 598:	05 90       	lpm	r0, Z+
 59a:	f4 91       	lpm	r31, Z+
 59c:	e0 2d       	mov	r30, r0
 59e:	09 94       	ijmp
		case 12: ;break;	//Wetterdaten
		case 13: ;break;	//Wetterdaten
		case 14: ;break;	//Wetterdaten
		case 15: ;break;	//Rufbit für PTB
		case 16: ;break; //Am Ende dieser Stunde wird auf MEZ/MESZ umgestellt
		case 17: dcf_timezone+=1;break;	//Zeitzone: 
 5a0:	80 91 97 00 	lds	r24, 0x0097
 5a4:	8f 5f       	subi	r24, 0xFF	; 255
 5a6:	80 93 97 00 	sts	0x0097, r24
 5aa:	08 95       	ret
		case 18: ;break;	//Zeitzone: dcf_timezone=dcf_timezone
		case 19: ;break;	//Am Ende diese Stunde wird eine Schaltsekunde eingefügt.
		case 20: ;break;	//Beginn der Zeitinformation (immer 1)
		case 21: dcf_minute+=1;dcf_minute_parity+=1;break;
 5ac:	80 91 a8 00 	lds	r24, 0x00A8
 5b0:	8f 5f       	subi	r24, 0xFF	; 255
 5b2:	17 c0       	rjmp	.+46     	; 0x5e2 <dcf_1+0x62>
		case 22: dcf_minute+=2;dcf_minute_parity+=1;break;
 5b4:	80 91 a8 00 	lds	r24, 0x00A8
 5b8:	8e 5f       	subi	r24, 0xFE	; 254
 5ba:	13 c0       	rjmp	.+38     	; 0x5e2 <dcf_1+0x62>
		case 23: dcf_minute+=4;dcf_minute_parity+=1;break;
 5bc:	80 91 a8 00 	lds	r24, 0x00A8
 5c0:	8c 5f       	subi	r24, 0xFC	; 252
 5c2:	0f c0       	rjmp	.+30     	; 0x5e2 <dcf_1+0x62>
		case 24: dcf_minute+=8;dcf_minute_parity+=1;break;
 5c4:	80 91 a8 00 	lds	r24, 0x00A8
 5c8:	88 5f       	subi	r24, 0xF8	; 248
 5ca:	0b c0       	rjmp	.+22     	; 0x5e2 <dcf_1+0x62>
		case 25: dcf_minute+=10;dcf_minute_parity+=1;break;
 5cc:	80 91 a8 00 	lds	r24, 0x00A8
 5d0:	86 5f       	subi	r24, 0xF6	; 246
 5d2:	07 c0       	rjmp	.+14     	; 0x5e2 <dcf_1+0x62>
		case 26: dcf_minute+=20;dcf_minute_parity+=1;break;
 5d4:	80 91 a8 00 	lds	r24, 0x00A8
 5d8:	8c 5e       	subi	r24, 0xEC	; 236
 5da:	03 c0       	rjmp	.+6      	; 0x5e2 <dcf_1+0x62>
		case 27: dcf_minute+=40;dcf_minute_parity+=1;break;
 5dc:	80 91 a8 00 	lds	r24, 0x00A8
 5e0:	88 5d       	subi	r24, 0xD8	; 216
 5e2:	80 93 a8 00 	sts	0x00A8, r24
		case 28: dcf_minute_parity+=1;break;	//Parität: Minute
 5e6:	80 91 a4 00 	lds	r24, 0x00A4
 5ea:	8f 5f       	subi	r24, 0xFF	; 255
 5ec:	80 93 a4 00 	sts	0x00A4, r24
 5f0:	08 95       	ret
		case 29: dcf_hour+=1;dcf_hour_parity+=1;break;
 5f2:	80 91 96 00 	lds	r24, 0x0096
 5f6:	8f 5f       	subi	r24, 0xFF	; 255
 5f8:	13 c0       	rjmp	.+38     	; 0x620 <dcf_1+0xa0>
		case 30: dcf_hour+=2;dcf_hour_parity+=1;break;
 5fa:	80 91 96 00 	lds	r24, 0x0096
 5fe:	8e 5f       	subi	r24, 0xFE	; 254
 600:	0f c0       	rjmp	.+30     	; 0x620 <dcf_1+0xa0>
		case 31: dcf_hour+=4;dcf_hour_parity+=1;break;
 602:	80 91 96 00 	lds	r24, 0x0096
 606:	8c 5f       	subi	r24, 0xFC	; 252
 608:	0b c0       	rjmp	.+22     	; 0x620 <dcf_1+0xa0>
		case 32: dcf_hour+=8;dcf_hour_parity+=1;break;
 60a:	80 91 96 00 	lds	r24, 0x0096
 60e:	88 5f       	subi	r24, 0xF8	; 248
 610:	07 c0       	rjmp	.+14     	; 0x620 <dcf_1+0xa0>
		case 33: dcf_hour+=10;dcf_hour_parity+=1;break;
 612:	80 91 96 00 	lds	r24, 0x0096
 616:	86 5f       	subi	r24, 0xF6	; 246
 618:	03 c0       	rjmp	.+6      	; 0x620 <dcf_1+0xa0>
		case 34: dcf_hour+=20;dcf_hour_parity+=1;break;
 61a:	80 91 96 00 	lds	r24, 0x0096
 61e:	8c 5e       	subi	r24, 0xEC	; 236
 620:	80 93 96 00 	sts	0x0096, r24
		case 35: dcf_hour_parity+=1;break;	//Parität: Stunde
 624:	80 91 99 00 	lds	r24, 0x0099
 628:	8f 5f       	subi	r24, 0xFF	; 255
 62a:	80 93 99 00 	sts	0x0099, r24
 62e:	08 95       	ret
		case 36: dcf_day+=1;dcf_date_parity+=1;break;
 630:	80 91 9e 00 	lds	r24, 0x009E
 634:	8f 5f       	subi	r24, 0xFF	; 255
 636:	13 c0       	rjmp	.+38     	; 0x65e <dcf_1+0xde>
		case 37: dcf_day+=2;dcf_date_parity+=1;break;
 638:	80 91 9e 00 	lds	r24, 0x009E
 63c:	8e 5f       	subi	r24, 0xFE	; 254
 63e:	0f c0       	rjmp	.+30     	; 0x65e <dcf_1+0xde>
		case 38: dcf_day+=4;dcf_date_parity+=1;break;
 640:	80 91 9e 00 	lds	r24, 0x009E
 644:	8c 5f       	subi	r24, 0xFC	; 252
 646:	0b c0       	rjmp	.+22     	; 0x65e <dcf_1+0xde>
		case 39: dcf_day+=8;dcf_date_parity+=1;break;
 648:	80 91 9e 00 	lds	r24, 0x009E
 64c:	88 5f       	subi	r24, 0xF8	; 248
 64e:	07 c0       	rjmp	.+14     	; 0x65e <dcf_1+0xde>
		case 40: dcf_day+=10;dcf_date_parity+=1;break;
 650:	80 91 9e 00 	lds	r24, 0x009E
 654:	86 5f       	subi	r24, 0xF6	; 246
 656:	03 c0       	rjmp	.+6      	; 0x65e <dcf_1+0xde>
		case 41: dcf_day+=20;dcf_date_parity+=1;break;
 658:	80 91 9e 00 	lds	r24, 0x009E
 65c:	8c 5e       	subi	r24, 0xEC	; 236
 65e:	80 93 9e 00 	sts	0x009E, r24
 662:	45 c0       	rjmp	.+138    	; 0x6ee <dcf_1+0x16e>
		case 42: dcf_week_day+=1;dcf_date_parity+=1;break;
 664:	80 91 98 00 	lds	r24, 0x0098
 668:	8f 5f       	subi	r24, 0xFF	; 255
 66a:	07 c0       	rjmp	.+14     	; 0x67a <dcf_1+0xfa>
		case 43: dcf_week_day+=2;dcf_date_parity+=1;break;
 66c:	80 91 98 00 	lds	r24, 0x0098
 670:	8e 5f       	subi	r24, 0xFE	; 254
 672:	03 c0       	rjmp	.+6      	; 0x67a <dcf_1+0xfa>
		case 44: dcf_week_day+=4;dcf_date_parity+=1;break;
 674:	80 91 98 00 	lds	r24, 0x0098
 678:	8c 5f       	subi	r24, 0xFC	; 252
 67a:	80 93 98 00 	sts	0x0098, r24
 67e:	37 c0       	rjmp	.+110    	; 0x6ee <dcf_1+0x16e>
		case 45: dcf_month+=1;dcf_date_parity+=1;break;
 680:	80 91 ab 00 	lds	r24, 0x00AB
 684:	8f 5f       	subi	r24, 0xFF	; 255
 686:	0f c0       	rjmp	.+30     	; 0x6a6 <dcf_1+0x126>
		case 46: dcf_month+=2;dcf_date_parity+=1;break;
 688:	80 91 ab 00 	lds	r24, 0x00AB
 68c:	8e 5f       	subi	r24, 0xFE	; 254
 68e:	0b c0       	rjmp	.+22     	; 0x6a6 <dcf_1+0x126>
		case 47: dcf_month+=4;dcf_date_parity+=1;break;
 690:	80 91 ab 00 	lds	r24, 0x00AB
 694:	8c 5f       	subi	r24, 0xFC	; 252
 696:	07 c0       	rjmp	.+14     	; 0x6a6 <dcf_1+0x126>
		case 48: dcf_month+=8;dcf_date_parity+=1;break;
 698:	80 91 ab 00 	lds	r24, 0x00AB
 69c:	88 5f       	subi	r24, 0xF8	; 248
 69e:	03 c0       	rjmp	.+6      	; 0x6a6 <dcf_1+0x126>
		case 49: dcf_month+=10;dcf_date_parity+=1;break;
 6a0:	80 91 ab 00 	lds	r24, 0x00AB
 6a4:	86 5f       	subi	r24, 0xF6	; 246
 6a6:	80 93 ab 00 	sts	0x00AB, r24
 6aa:	21 c0       	rjmp	.+66     	; 0x6ee <dcf_1+0x16e>
		case 50: dcf_year+=1;dcf_date_parity+=1;break;
 6ac:	80 91 9a 00 	lds	r24, 0x009A
 6b0:	8f 5f       	subi	r24, 0xFF	; 255
 6b2:	1b c0       	rjmp	.+54     	; 0x6ea <dcf_1+0x16a>
		case 51: dcf_year+=2;dcf_date_parity+=1;break;
 6b4:	80 91 9a 00 	lds	r24, 0x009A
 6b8:	8e 5f       	subi	r24, 0xFE	; 254
 6ba:	17 c0       	rjmp	.+46     	; 0x6ea <dcf_1+0x16a>
		case 52: dcf_year+=4;dcf_date_parity+=1;break;
 6bc:	80 91 9a 00 	lds	r24, 0x009A
 6c0:	8c 5f       	subi	r24, 0xFC	; 252
 6c2:	13 c0       	rjmp	.+38     	; 0x6ea <dcf_1+0x16a>
		case 53: dcf_year+=8;dcf_date_parity+=1;break;
 6c4:	80 91 9a 00 	lds	r24, 0x009A
 6c8:	88 5f       	subi	r24, 0xF8	; 248
 6ca:	0f c0       	rjmp	.+30     	; 0x6ea <dcf_1+0x16a>
		case 54: dcf_year+=10;dcf_date_parity+=1;break;
 6cc:	80 91 9a 00 	lds	r24, 0x009A
 6d0:	86 5f       	subi	r24, 0xF6	; 246
 6d2:	0b c0       	rjmp	.+22     	; 0x6ea <dcf_1+0x16a>
		case 55: dcf_year+=20;dcf_date_parity+=1;break;
 6d4:	80 91 9a 00 	lds	r24, 0x009A
 6d8:	8c 5e       	subi	r24, 0xEC	; 236
 6da:	07 c0       	rjmp	.+14     	; 0x6ea <dcf_1+0x16a>
		case 56: dcf_year+=40;dcf_date_parity+=1;break;
 6dc:	80 91 9a 00 	lds	r24, 0x009A
 6e0:	88 5d       	subi	r24, 0xD8	; 216
 6e2:	03 c0       	rjmp	.+6      	; 0x6ea <dcf_1+0x16a>
		case 57: dcf_year+=80;dcf_date_parity+=1;break;
 6e4:	80 91 9a 00 	lds	r24, 0x009A
 6e8:	80 5b       	subi	r24, 0xB0	; 176
 6ea:	80 93 9a 00 	sts	0x009A, r24
		case 58: dcf_date_parity+=1;break;	//Parität: Datum
 6ee:	80 91 a9 00 	lds	r24, 0x00A9
 6f2:	8f 5f       	subi	r24, 0xFF	; 255
 6f4:	80 93 a9 00 	sts	0x00A9, r24
 6f8:	08 95       	ret
		case 59: dcf_sync();break;	//keine Absenkung --> neue Minute
 6fa:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>
 6fe:	08 95       	ret
		default: dcf_sync();break;
 700:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>
 704:	08 95       	ret

00000706 <dcf_0>:
//////////////////
//DCF-Auswertung//
//////////////////
void dcf_0(void)
{
	switch(bit_number)
 706:	80 91 b8 00 	lds	r24, 0x00B8
 70a:	83 31       	cpi	r24, 0x13	; 19
 70c:	c1 f0       	breq	.+48     	; 0x73e <dcf_0+0x38>
 70e:	84 31       	cpi	r24, 0x14	; 20
 710:	18 f4       	brcc	.+6      	; 0x718 <dcf_0+0x12>
 712:	82 31       	cpi	r24, 0x12	; 18
 714:	a0 f0       	brcs	.+40     	; 0x73e <dcf_0+0x38>
 716:	08 c0       	rjmp	.+16     	; 0x728 <dcf_0+0x22>
 718:	8b 33       	cpi	r24, 0x3B	; 59
 71a:	18 f4       	brcc	.+6      	; 0x722 <dcf_0+0x1c>
 71c:	85 31       	cpi	r24, 0x15	; 21
 71e:	78 f4       	brcc	.+30     	; 0x73e <dcf_0+0x38>
 720:	09 c0       	rjmp	.+18     	; 0x734 <dcf_0+0x2e>
 722:	8b 33       	cpi	r24, 0x3B	; 59
 724:	51 f4       	brne	.+20     	; 0x73a <dcf_0+0x34>
 726:	06 c0       	rjmp	.+12     	; 0x734 <dcf_0+0x2e>
		case 13: ;break;	//Wetterdaten
		case 14: ;break;	//Wetterdaten
		case 15: ;break;	//Rufbit für PTB
		case 16: ;break; //Keine Änderung der Zeitzone
		case 17: ;break;	//Zeitzone: dcf_timezone=dcf_timezone
		case 18: dcf_timezone+=1;break;	//Zeitzone: 
 728:	80 91 97 00 	lds	r24, 0x0097
 72c:	8f 5f       	subi	r24, 0xFF	; 255
 72e:	80 93 97 00 	sts	0x0097, r24
 732:	08 95       	ret
		case 54: ;break;
		case 55: ;break;
		case 56: ;break;
		case 57: ;break;
		case 58: ;break;	//Parität: Datum
		case 59: dcf_sync();break;	//keine Absenkung --> neue Minute
 734:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>
 738:	08 95       	ret
		default: dcf_sync();break;
 73a:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>
 73e:	08 95       	ret

00000740 <level_analysis>:
///////////////////////
//DCF-Pegelauswertung//
///////////////////////
void level_analysis(void)
{
	if(dataPC & (1<<PINC1))
 740:	80 91 a3 00 	lds	r24, 0x00A3
 744:	81 ff       	sbrs	r24, 1
 746:	2b c0       	rjmp	.+86     	; 0x79e <level_analysis+0x5e>
	{

		if(counter_low>=60 && counter_low<=140)	//logisch 0
 748:	20 91 b4 00 	lds	r18, 0x00B4
 74c:	30 91 b5 00 	lds	r19, 0x00B5
 750:	c9 01       	movw	r24, r18
 752:	cc 97       	sbiw	r24, 0x3c	; 60
 754:	81 35       	cpi	r24, 0x51	; 81
 756:	91 05       	cpc	r25, r1
 758:	68 f4       	brcc	.+26     	; 0x774 <level_analysis+0x34>
		{
//			minute_frame[bit_number]=0;			

			dcf_0();
 75a:	0e 94 83 03 	call	0x706	; 0x706 <dcf_0>
	
			bit_number++;
 75e:	80 91 b8 00 	lds	r24, 0x00B8
 762:	8f 5f       	subi	r24, 0xFF	; 255
 764:	80 93 b8 00 	sts	0x00B8, r24
			dcf_second++;
 768:	80 91 aa 00 	lds	r24, 0x00AA
 76c:	8f 5f       	subi	r24, 0xFF	; 255
 76e:	80 93 aa 00 	sts	0x00AA, r24
 772:	0c c0       	rjmp	.+24     	; 0x78c <level_analysis+0x4c>
			counter_high=0;
			counter_low=0;
		}
		else
		{
			if(counter_low>=160 && counter_low<=240)	//logisch 1
 774:	20 5a       	subi	r18, 0xA0	; 160
 776:	30 40       	sbci	r19, 0x00	; 0
 778:	21 35       	cpi	r18, 0x51	; 81
 77a:	31 05       	cpc	r19, r1
 77c:	58 f4       	brcc	.+22     	; 0x794 <level_analysis+0x54>
			{
//				minute_frame[bit_number]=1;			
				
				dcf_1();
 77e:	0e 94 c0 02 	call	0x580	; 0x580 <dcf_1>

				bit_number++;
 782:	80 91 b8 00 	lds	r24, 0x00B8
 786:	8f 5f       	subi	r24, 0xFF	; 255
 788:	80 93 b8 00 	sts	0x00B8, r24

				counter_high=0;
 78c:	10 92 b7 00 	sts	0x00B7, r1
 790:	10 92 b6 00 	sts	0x00B6, r1
				counter_low=0;
			}
			else
			{
				counter_low=0;
 794:	10 92 b5 00 	sts	0x00B5, r1
 798:	10 92 b4 00 	sts	0x00B4, r1
 79c:	08 95       	ret
			}
		}
	}
	else
	{
		if(counter_high>=1750 && counter_high<=1950)
 79e:	80 91 b6 00 	lds	r24, 0x00B6
 7a2:	90 91 b7 00 	lds	r25, 0x00B7
 7a6:	86 5d       	subi	r24, 0xD6	; 214
 7a8:	96 40       	sbci	r25, 0x06	; 6
 7aa:	89 3c       	cpi	r24, 0xC9	; 201
 7ac:	91 05       	cpc	r25, r1
 7ae:	08 f0       	brcs	.+2      	; 0x7b2 <level_analysis+0x72>
 7b0:	6c c0       	rjmp	.+216    	; 0x88a <level_analysis+0x14a>
		{
			if(bit_number==59 && dcf_minute_parity%2==0 && dcf_hour_parity%2==0 && dcf_date_parity%2==0)
 7b2:	80 91 b8 00 	lds	r24, 0x00B8
 7b6:	8b 33       	cpi	r24, 0x3B	; 59
 7b8:	b1 f5       	brne	.+108    	; 0x826 <level_analysis+0xe6>
 7ba:	80 91 a4 00 	lds	r24, 0x00A4
 7be:	80 fd       	sbrc	r24, 0
 7c0:	32 c0       	rjmp	.+100    	; 0x826 <level_analysis+0xe6>
 7c2:	80 91 99 00 	lds	r24, 0x0099
 7c6:	80 fd       	sbrc	r24, 0
 7c8:	2e c0       	rjmp	.+92     	; 0x826 <level_analysis+0xe6>
 7ca:	80 91 a9 00 	lds	r24, 0x00A9
 7ce:	80 fd       	sbrc	r24, 0
 7d0:	2a c0       	rjmp	.+84     	; 0x826 <level_analysis+0xe6>
			{
				bit_number=0;
 7d2:	10 92 b8 00 	sts	0x00B8, r1
////////////////////////////////////////////////////////
//Zusammenführung der internen Daten und der DCF-Daten//
////////////////////////////////////////////////////////
void match_date(void)
{
	week_day=dcf_week_day;
 7d6:	80 91 98 00 	lds	r24, 0x0098
 7da:	80 93 a2 00 	sts	0x00A2, r24
	day=dcf_day;
 7de:	80 91 9e 00 	lds	r24, 0x009E
 7e2:	80 93 a7 00 	sts	0x00A7, r24
	month=dcf_month;
 7e6:	80 91 ab 00 	lds	r24, 0x00AB
 7ea:	80 93 9c 00 	sts	0x009C, r24
	year=2000+dcf_year;
 7ee:	80 91 9a 00 	lds	r24, 0x009A
 7f2:	90 e0       	ldi	r25, 0x00	; 0
 7f4:	80 53       	subi	r24, 0x30	; 48
 7f6:	98 4f       	sbci	r25, 0xF8	; 248
 7f8:	90 93 a6 00 	sts	0x00A6, r25
 7fc:	80 93 a5 00 	sts	0x00A5, r24
}

void match_time(void)
{
	millisecond=0;
 800:	10 92 95 00 	sts	0x0095, r1
 804:	10 92 94 00 	sts	0x0094, r1
	second=0;
 808:	10 92 9d 00 	sts	0x009D, r1
	minute=dcf_minute;
 80c:	80 91 a8 00 	lds	r24, 0x00A8
 810:	80 93 9f 00 	sts	0x009F, r24
	hour=dcf_hour;
 814:	80 91 96 00 	lds	r24, 0x0096
 818:	80 93 a1 00 	sts	0x00A1, r24
	timezone=dcf_timezone;
 81c:	80 91 97 00 	lds	r24, 0x0097
 820:	80 93 a0 00 	sts	0x00A0, r24
 824:	1a c0       	rjmp	.+52     	; 0x85a <level_analysis+0x11a>
	bit_number=0;
}

void dcf_date_reset(void)
{
	dcf_week_day=0;
 826:	10 92 98 00 	sts	0x0098, r1
	dcf_day=0;
 82a:	10 92 9e 00 	sts	0x009E, r1
	dcf_month=0;
 82e:	10 92 ab 00 	sts	0x00AB, r1
	dcf_year=0;
 832:	10 92 9a 00 	sts	0x009A, r1
	dcf_date_parity=0;
 836:	10 92 a9 00 	sts	0x00A9, r1
}

void dcf_time_reset(void)
{
	dcf_minute=0;
 83a:	10 92 a8 00 	sts	0x00A8, r1
	dcf_minute_parity=0;
 83e:	10 92 a4 00 	sts	0x00A4, r1
	dcf_hour=0;
 842:	10 92 96 00 	sts	0x0096, r1
	dcf_hour_parity=0;
 846:	10 92 99 00 	sts	0x0099, r1
	dcf_timezone=0;
 84a:	10 92 97 00 	sts	0x0097, r1
			else
			{
				dcf_date_reset();
				dcf_time_reset();

				counter_high=0;
 84e:	10 92 b7 00 	sts	0x00B7, r1
 852:	10 92 b6 00 	sts	0x00B6, r1

				dcf_sync();
 856:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>
			}

			counter_high=0;
 85a:	10 92 b7 00 	sts	0x00B7, r1
 85e:	10 92 b6 00 	sts	0x00B6, r1
	bit_number=0;
}

void dcf_date_reset(void)
{
	dcf_week_day=0;
 862:	10 92 98 00 	sts	0x0098, r1
	dcf_day=0;
 866:	10 92 9e 00 	sts	0x009E, r1
	dcf_month=0;
 86a:	10 92 ab 00 	sts	0x00AB, r1
	dcf_year=0;
 86e:	10 92 9a 00 	sts	0x009A, r1
	dcf_date_parity=0;
 872:	10 92 a9 00 	sts	0x00A9, r1
}

void dcf_time_reset(void)
{
	dcf_minute=0;
 876:	10 92 a8 00 	sts	0x00A8, r1
	dcf_minute_parity=0;
 87a:	10 92 a4 00 	sts	0x00A4, r1
	dcf_hour=0;
 87e:	10 92 96 00 	sts	0x0096, r1
	dcf_hour_parity=0;
 882:	10 92 99 00 	sts	0x0099, r1
	dcf_timezone=0;
 886:	10 92 97 00 	sts	0x0097, r1
 88a:	08 95       	ret

0000088c <main>:
//Main//
////////
int main(void)
{
	//Setzen der Port-Richtungsregister
	DDRB |= (1<<PB0);	//PB0 Ausgang (1)
 88c:	b8 9a       	sbi	0x17, 0	; 23
	DDRC &= ~(1<<PC1);	//PC1 Eingang (0)
 88e:	a1 98       	cbi	0x14, 1	; 20
	//Initialisieren der Ports
	PORTB &= ~(1<<PB0);	//PB0 auf low gesetzt (0)
 890:	c0 98       	cbi	0x18, 0	; 24
	PORTC |= (1<<PC1);	//PC1 Pull-Up gesetzt (1)
 892:	a9 9a       	sbi	0x15, 1	; 21

	lcd_init();	//Initialisierung des LCDs
 894:	0e 94 8e 04 	call	0x91c	; 0x91c <lcd_init>

	// Timer 0 konfigurieren
	TCCR0 = (1<<WGM01) | (1<<CS00) | (1<<CS01);	//CTC Modus (1), Prescaler 64 (1) (1)
 898:	8b e0       	ldi	r24, 0x0B	; 11
 89a:	83 bf       	out	0x33, r24	; 51
	OCR0 = 250-1; //((16000000/64)/1000) = 250
 89c:	89 ef       	ldi	r24, 0xF9	; 249
 89e:	8c bf       	out	0x3c, r24	; 60
	TIMSK |= (1<<OCIE0);	//Compare Interrupt erlauben (1)
 8a0:	89 b7       	in	r24, 0x39	; 57
 8a2:	82 60       	ori	r24, 0x02	; 2
 8a4:	89 bf       	out	0x39, r24	; 57
	sei();	//Global Interrupts aktivieren
 8a6:	78 94       	sei

	dcf_sync();	//Synchronisierung des DCF-Moduls
 8a8:	0e 94 79 02 	call	0x4f2	; 0x4f2 <dcf_sync>

	while(1)
	{
		level_analysis();
 8ac:	0e 94 a0 03 	call	0x740	; 0x740 <level_analysis>
		show_matched_date(0,1);
 8b0:	80 e0       	ldi	r24, 0x00	; 0
 8b2:	61 e0       	ldi	r22, 0x01	; 1
 8b4:	0e 94 0e 02 	call	0x41c	; 0x41c <show_matched_date>
		show_matched_time(0,2);
 8b8:	80 e0       	ldi	r24, 0x00	; 0
 8ba:	62 e0       	ldi	r22, 0x02	; 2
 8bc:	0e 94 be 01 	call	0x37c	; 0x37c <show_matched_time>
 8c0:	f5 cf       	rjmp	.-22     	; 0x8ac <main+0x20>

000008c2 <lcd_command>:
// sendet einen Befehl an das LCD
void lcd_command(unsigned char temp1)
{
   unsigned char temp2 = temp1;
 
   LCD_PORT &= ~(1<<LCD_RS);        // RS auf 0 setzen
 8c2:	94 98       	cbi	0x12, 4	; 18
 
   temp1 = temp1 >> 4;              // oberes Nibble holen
   temp1 = temp1 & 0x0F;            // maskieren
   LCD_PORT &= 0xF0;
 8c4:	92 b3       	in	r25, 0x12	; 18
 8c6:	90 7f       	andi	r25, 0xF0	; 240
 8c8:	92 bb       	out	0x12, r25	; 18
   LCD_PORT |= temp1;               // setzen
 8ca:	22 b3       	in	r18, 0x12	; 18
 8cc:	98 2f       	mov	r25, r24
 8ce:	92 95       	swap	r25
 8d0:	9f 70       	andi	r25, 0x0F	; 15
 8d2:	92 2b       	or	r25, r18
 8d4:	92 bb       	out	0x12, r25	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 8d6:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 8d8:	25 e0       	ldi	r18, 0x05	; 5
 8da:	92 2f       	mov	r25, r18
 8dc:	9a 95       	dec	r25
 8de:	f1 f7       	brne	.-4      	; 0x8dc <lcd_command+0x1a>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 8e0:	95 98       	cbi	0x12, 5	; 18
   LCD_PORT &= 0xF0;
   LCD_PORT |= temp1;               // setzen
   lcd_enable();
 
   temp2 = temp2 & 0x0F;            // unteres Nibble holen und maskieren
   LCD_PORT &= 0xF0;
 8e2:	92 b3       	in	r25, 0x12	; 18
 8e4:	90 7f       	andi	r25, 0xF0	; 240
 8e6:	92 bb       	out	0x12, r25	; 18
   LCD_PORT |= temp2;               // setzen
 8e8:	92 b3       	in	r25, 0x12	; 18
 8ea:	8f 70       	andi	r24, 0x0F	; 15
 8ec:	98 2b       	or	r25, r24
 8ee:	92 bb       	out	0x12, r25	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 8f0:	95 9a       	sbi	0x12, 5	; 18
 8f2:	2a 95       	dec	r18
 8f4:	f1 f7       	brne	.-4      	; 0x8f2 <lcd_command+0x30>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 8f6:	95 98       	cbi	0x12, 5	; 18
 8f8:	80 ee       	ldi	r24, 0xE0	; 224
 8fa:	8a 95       	dec	r24
 8fc:	f1 f7       	brne	.-4      	; 0x8fa <lcd_command+0x38>
   LCD_PORT &= 0xF0;
   LCD_PORT |= temp2;               // setzen
   lcd_enable();
   
   _delay_us(42);
}
 8fe:	08 95       	ret

00000900 <lcd_enable>:
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 900:	95 9a       	sbi	0x12, 5	; 18
 902:	85 e0       	ldi	r24, 0x05	; 5
 904:	8a 95       	dec	r24
 906:	f1 f7       	brne	.-4      	; 0x904 <lcd_enable+0x4>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 908:	95 98       	cbi	0x12, 5	; 18
}
 90a:	08 95       	ret

0000090c <lcd_clear>:
}
 
// Sendet den Befehl zur Löschung des Displays
void lcd_clear(void)
{
   lcd_command(CLEAR_DISPLAY);
 90c:	81 e0       	ldi	r24, 0x01	; 1
 90e:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 912:	80 e2       	ldi	r24, 0x20	; 32
 914:	9e e4       	ldi	r25, 0x4E	; 78
 916:	01 97       	sbiw	r24, 0x01	; 1
 918:	f1 f7       	brne	.-4      	; 0x916 <lcd_clear+0xa>
   _delay_ms(5);
}
 91a:	08 95       	ret

0000091c <lcd_init>:
 
// Initialisierung: 
// Muss ganz am Anfang des Programms aufgerufen werden.
void lcd_init(void)
{
   LCD_DDR = LCD_DDR | 0x0F | (1<<LCD_RS) | (1<<LCD_EN);   // Port auf Ausgang schalten
 91c:	81 b3       	in	r24, 0x11	; 17
 91e:	8f 63       	ori	r24, 0x3F	; 63
 920:	81 bb       	out	0x11, r24	; 17
 922:	80 e6       	ldi	r24, 0x60	; 96
 924:	9a ee       	ldi	r25, 0xEA	; 234
 926:	01 97       	sbiw	r24, 0x01	; 1
 928:	f1 f7       	brne	.-4      	; 0x926 <lcd_init+0xa>
 
   // muss 3mal hintereinander gesendet werden zur Initialisierung
   _delay_ms(15);
   LCD_PORT &= 0xF0;
 92a:	82 b3       	in	r24, 0x12	; 18
 92c:	80 7f       	andi	r24, 0xF0	; 240
 92e:	82 bb       	out	0x12, r24	; 18
   LCD_PORT |= 0x03;            
 930:	82 b3       	in	r24, 0x12	; 18
 932:	83 60       	ori	r24, 0x03	; 3
 934:	82 bb       	out	0x12, r24	; 18
   LCD_PORT &= ~(1<<LCD_RS);      // RS auf 0
 936:	94 98       	cbi	0x12, 4	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 938:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 93a:	95 e0       	ldi	r25, 0x05	; 5
 93c:	89 2f       	mov	r24, r25
 93e:	8a 95       	dec	r24
 940:	f1 f7       	brne	.-4      	; 0x93e <lcd_init+0x22>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 942:	95 98       	cbi	0x12, 5	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 944:	e0 e2       	ldi	r30, 0x20	; 32
 946:	fe e4       	ldi	r31, 0x4E	; 78
 948:	31 97       	sbiw	r30, 0x01	; 1
 94a:	f1 f7       	brne	.-4      	; 0x948 <lcd_init+0x2c>
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 94c:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 94e:	89 2f       	mov	r24, r25
 950:	8a 95       	dec	r24
 952:	f1 f7       	brne	.-4      	; 0x950 <lcd_init+0x34>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 954:	95 98       	cbi	0x12, 5	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 956:	20 ea       	ldi	r18, 0xA0	; 160
 958:	3f e0       	ldi	r19, 0x0F	; 15
 95a:	f9 01       	movw	r30, r18
 95c:	31 97       	sbiw	r30, 0x01	; 1
 95e:	f1 f7       	brne	.-4      	; 0x95c <lcd_init+0x40>
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 960:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 962:	89 2f       	mov	r24, r25
 964:	8a 95       	dec	r24
 966:	f1 f7       	brne	.-4      	; 0x964 <lcd_init+0x48>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 968:	95 98       	cbi	0x12, 5	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 96a:	f9 01       	movw	r30, r18
 96c:	31 97       	sbiw	r30, 0x01	; 1
 96e:	f1 f7       	brne	.-4      	; 0x96c <lcd_init+0x50>
   _delay_ms(1);
   lcd_enable();
   _delay_ms(1);
 
   // 4 Bit Modus aktivieren 
   LCD_PORT &= 0xF0;
 970:	82 b3       	in	r24, 0x12	; 18
 972:	80 7f       	andi	r24, 0xF0	; 240
 974:	82 bb       	out	0x12, r24	; 18
   LCD_PORT |= 0x02;
 976:	91 9a       	sbi	0x12, 1	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 978:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 97a:	9a 95       	dec	r25
 97c:	f1 f7       	brne	.-4      	; 0x97a <lcd_init+0x5e>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 97e:	95 98       	cbi	0x12, 5	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 980:	c9 01       	movw	r24, r18
 982:	01 97       	sbiw	r24, 0x01	; 1
 984:	f1 f7       	brne	.-4      	; 0x982 <lcd_init+0x66>
   LCD_PORT |= 0x02;
   lcd_enable();
   _delay_ms(1);
 
   // 4Bit / 2 Zeilen / 5x7
   lcd_command(0x28);
 986:	88 e2       	ldi	r24, 0x28	; 40
 988:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
    
   // Display ein / Cursor aus / kein Blinken
   lcd_command(0x0C); 
 98c:	8c e0       	ldi	r24, 0x0C	; 12
 98e:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
 
   // inkrement / kein Scrollen
   lcd_command(0x06);
 992:	86 e0       	ldi	r24, 0x06	; 6
 994:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
 
   lcd_clear();
 998:	0e 94 86 04 	call	0x90c	; 0x90c <lcd_clear>
}
 99c:	08 95       	ret

0000099e <lcd_home>:
}
 
// Sendet den Befehl: Cursor Home
void lcd_home(void)
{
   lcd_command(CURSOR_HOME);
 99e:	82 e0       	ldi	r24, 0x02	; 2
 9a0:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
 9a4:	80 e2       	ldi	r24, 0x20	; 32
 9a6:	9e e4       	ldi	r25, 0x4E	; 78
 9a8:	01 97       	sbiw	r24, 0x01	; 1
 9aa:	f1 f7       	brne	.-4      	; 0x9a8 <lcd_home+0xa>
   _delay_ms(5);
}
 9ac:	08 95       	ret

000009ae <set_cursor>:
// setzt den Cursor in Zeile y (1..4) Spalte x (0..15)
void set_cursor(uint8_t x, uint8_t y)
{
  uint8_t tmp;
 
  switch (y)
 9ae:	62 30       	cpi	r22, 0x02	; 2
 9b0:	61 f0       	breq	.+24     	; 0x9ca <set_cursor+0x1c>
 9b2:	63 30       	cpi	r22, 0x03	; 3
 9b4:	18 f4       	brcc	.+6      	; 0x9bc <set_cursor+0xe>
 9b6:	61 30       	cpi	r22, 0x01	; 1
 9b8:	79 f4       	brne	.+30     	; 0x9d8 <set_cursor+0x2a>
 9ba:	05 c0       	rjmp	.+10     	; 0x9c6 <set_cursor+0x18>
 9bc:	63 30       	cpi	r22, 0x03	; 3
 9be:	39 f0       	breq	.+14     	; 0x9ce <set_cursor+0x20>
 9c0:	64 30       	cpi	r22, 0x04	; 4
 9c2:	51 f4       	brne	.+20     	; 0x9d8 <set_cursor+0x2a>
 9c4:	06 c0       	rjmp	.+12     	; 0x9d2 <set_cursor+0x24>
  {
    case 1: tmp=0x80+0x00+x; break;    // 1. Zeile
 9c6:	80 58       	subi	r24, 0x80	; 128
 9c8:	05 c0       	rjmp	.+10     	; 0x9d4 <set_cursor+0x26>
    case 2: tmp=0x80+0x40+x; break;    // 2. Zeile
 9ca:	80 54       	subi	r24, 0x40	; 64
 9cc:	03 c0       	rjmp	.+6      	; 0x9d4 <set_cursor+0x26>
    case 3: tmp=0x80+0x14+x; break;    // 3. Zeile (Angepasst auf 20 Spalten 0x14 statt 0x10)
 9ce:	8c 56       	subi	r24, 0x6C	; 108
 9d0:	01 c0       	rjmp	.+2      	; 0x9d4 <set_cursor+0x26>
    case 4: tmp=0x80+0x54+x; break;    // 4. Zeile (Angepasst auf 20 Spalten 0x54 statt 0x50)
 9d2:	8c 52       	subi	r24, 0x2C	; 44
    default: return;                   // für den Fall einer falschen Zeile
  }
  lcd_command(tmp);
 9d4:	0e 94 61 04 	call	0x8c2	; 0x8c2 <lcd_command>
 9d8:	08 95       	ret

000009da <lcd_data>:
// sendet ein Datenbyte an das LCD
void lcd_data(unsigned char temp1)
{
   unsigned char temp2 = temp1;
 
   LCD_PORT |= (1<<LCD_RS);        // RS auf 1 setzen
 9da:	94 9a       	sbi	0x12, 4	; 18
 
   temp1 = temp1 >> 4;
   temp1 = temp1 & 0x0F;
   LCD_PORT &= 0xF0;
 9dc:	92 b3       	in	r25, 0x12	; 18
 9de:	90 7f       	andi	r25, 0xF0	; 240
 9e0:	92 bb       	out	0x12, r25	; 18
   LCD_PORT |= temp1;               // setzen
 9e2:	22 b3       	in	r18, 0x12	; 18
 9e4:	98 2f       	mov	r25, r24
 9e6:	92 95       	swap	r25
 9e8:	9f 70       	andi	r25, 0x0F	; 15
 9ea:	92 2b       	or	r25, r18
 9ec:	92 bb       	out	0x12, r25	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 9ee:	95 9a       	sbi	0x12, 5	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 9f0:	25 e0       	ldi	r18, 0x05	; 5
 9f2:	92 2f       	mov	r25, r18
 9f4:	9a 95       	dec	r25
 9f6:	f1 f7       	brne	.-4      	; 0x9f4 <lcd_data+0x1a>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 9f8:	95 98       	cbi	0x12, 5	; 18
   LCD_PORT &= 0xF0;
   LCD_PORT |= temp1;               // setzen
   lcd_enable();
 
   temp2 = temp2 & 0x0F;
   LCD_PORT &= 0xF0;
 9fa:	92 b3       	in	r25, 0x12	; 18
 9fc:	90 7f       	andi	r25, 0xF0	; 240
 9fe:	92 bb       	out	0x12, r25	; 18
   LCD_PORT |= temp2;               // setzen
 a00:	92 b3       	in	r25, 0x12	; 18
 a02:	8f 70       	andi	r24, 0x0F	; 15
 a04:	98 2b       	or	r25, r24
 a06:	92 bb       	out	0x12, r25	; 18
// erzeugt den Enable-Puls
void lcd_enable(void)
{
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers einfügen
   // http://www.mikrocontroller.net/topic/81974#685882
   LCD_PORT |= (1<<LCD_EN);
 a08:	95 9a       	sbi	0x12, 5	; 18
 a0a:	2a 95       	dec	r18
 a0c:	f1 f7       	brne	.-4      	; 0xa0a <lcd_data+0x30>
    _delay_us(1);                   // kurze Pause
   // Bei Problemen ggf. Pause gemäß Datenblatt des LCD Controllers verlängern
   // http://www.mikrocontroller.net/topic/80900
   LCD_PORT &= ~(1<<LCD_EN);
 a0e:	95 98       	cbi	0x12, 5	; 18
 a10:	80 ee       	ldi	r24, 0xE0	; 224
 a12:	8a 95       	dec	r24
 a14:	f1 f7       	brne	.-4      	; 0xa12 <lcd_data+0x38>
   LCD_PORT &= 0xF0;
   LCD_PORT |= temp2;               // setzen
   lcd_enable();
   
   _delay_us(42);
}
 a16:	08 95       	ret

00000a18 <lcd_string>:

// Schreibt einen String auf das LCD
void lcd_string(char *data)
{
 a18:	cf 93       	push	r28
 a1a:	df 93       	push	r29
 a1c:	ec 01       	movw	r28, r24
 a1e:	03 c0       	rjmp	.+6      	; 0xa26 <lcd_string+0xe>
    while(*data)
	{
        lcd_data(*data);
 a20:	0e 94 ed 04 	call	0x9da	; 0x9da <lcd_data>
        data++;
 a24:	21 96       	adiw	r28, 0x01	; 1
}

// Schreibt einen String auf das LCD
void lcd_string(char *data)
{
    while(*data)
 a26:	88 81       	ld	r24, Y
 a28:	88 23       	and	r24, r24
 a2a:	d1 f7       	brne	.-12     	; 0xa20 <lcd_string+0x8>
	{
        lcd_data(*data);
        data++;
    }
}
 a2c:	df 91       	pop	r29
 a2e:	cf 91       	pop	r28
 a30:	08 95       	ret

00000a32 <__udivmodhi4>:
 a32:	aa 1b       	sub	r26, r26
 a34:	bb 1b       	sub	r27, r27
 a36:	51 e1       	ldi	r21, 0x11	; 17
 a38:	07 c0       	rjmp	.+14     	; 0xa48 <__udivmodhi4_ep>

00000a3a <__udivmodhi4_loop>:
 a3a:	aa 1f       	adc	r26, r26
 a3c:	bb 1f       	adc	r27, r27
 a3e:	a6 17       	cp	r26, r22
 a40:	b7 07       	cpc	r27, r23
 a42:	10 f0       	brcs	.+4      	; 0xa48 <__udivmodhi4_ep>
 a44:	a6 1b       	sub	r26, r22
 a46:	b7 0b       	sbc	r27, r23

00000a48 <__udivmodhi4_ep>:
 a48:	88 1f       	adc	r24, r24
 a4a:	99 1f       	adc	r25, r25
 a4c:	5a 95       	dec	r21
 a4e:	a9 f7       	brne	.-22     	; 0xa3a <__udivmodhi4_loop>
 a50:	80 95       	com	r24
 a52:	90 95       	com	r25
 a54:	bc 01       	movw	r22, r24
 a56:	cd 01       	movw	r24, r26
 a58:	08 95       	ret

00000a5a <itoa>:
 a5a:	fb 01       	movw	r30, r22
 a5c:	9f 01       	movw	r18, r30
 a5e:	e8 94       	clt
 a60:	42 30       	cpi	r20, 0x02	; 2
 a62:	c4 f0       	brlt	.+48     	; 0xa94 <itoa+0x3a>
 a64:	45 32       	cpi	r20, 0x25	; 37
 a66:	b4 f4       	brge	.+44     	; 0xa94 <itoa+0x3a>
 a68:	4a 30       	cpi	r20, 0x0A	; 10
 a6a:	29 f4       	brne	.+10     	; 0xa76 <itoa+0x1c>
 a6c:	97 fb       	bst	r25, 7
 a6e:	1e f4       	brtc	.+6      	; 0xa76 <itoa+0x1c>
 a70:	90 95       	com	r25
 a72:	81 95       	neg	r24
 a74:	9f 4f       	sbci	r25, 0xFF	; 255
 a76:	64 2f       	mov	r22, r20
 a78:	77 27       	eor	r23, r23
 a7a:	0e 94 19 05 	call	0xa32	; 0xa32 <__udivmodhi4>
 a7e:	80 5d       	subi	r24, 0xD0	; 208
 a80:	8a 33       	cpi	r24, 0x3A	; 58
 a82:	0c f0       	brlt	.+2      	; 0xa86 <itoa+0x2c>
 a84:	89 5d       	subi	r24, 0xD9	; 217
 a86:	81 93       	st	Z+, r24
 a88:	cb 01       	movw	r24, r22
 a8a:	00 97       	sbiw	r24, 0x00	; 0
 a8c:	a1 f7       	brne	.-24     	; 0xa76 <itoa+0x1c>
 a8e:	16 f4       	brtc	.+4      	; 0xa94 <itoa+0x3a>
 a90:	5d e2       	ldi	r21, 0x2D	; 45
 a92:	51 93       	st	Z+, r21
 a94:	10 82       	st	Z, r1
 a96:	c9 01       	movw	r24, r18
 a98:	0c 94 4e 05 	jmp	0xa9c	; 0xa9c <strrev>

00000a9c <strrev>:
 a9c:	dc 01       	movw	r26, r24
 a9e:	fc 01       	movw	r30, r24
 aa0:	67 2f       	mov	r22, r23
 aa2:	71 91       	ld	r23, Z+
 aa4:	77 23       	and	r23, r23
 aa6:	e1 f7       	brne	.-8      	; 0xaa0 <strrev+0x4>
 aa8:	32 97       	sbiw	r30, 0x02	; 2
 aaa:	04 c0       	rjmp	.+8      	; 0xab4 <strrev+0x18>
 aac:	7c 91       	ld	r23, X
 aae:	6d 93       	st	X+, r22
 ab0:	70 83       	st	Z, r23
 ab2:	62 91       	ld	r22, -Z
 ab4:	ae 17       	cp	r26, r30
 ab6:	bf 07       	cpc	r27, r31
 ab8:	c8 f3       	brcs	.-14     	; 0xaac <strrev+0x10>
 aba:	08 95       	ret

00000abc <_exit>:
 abc:	f8 94       	cli

00000abe <__stop_program>:
 abe:	ff cf       	rjmp	.-2      	; 0xabe <__stop_program>
